---
title: "mvMORPH: Habitat + Lens Size"
author: "H. Christoph Liedtke"
date: "21/05/2021"
output:
  html_document:
    theme: flatly
    highlight: breezedark
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true 
---

mvMORPH script for Habitat __with lens size__. The dataset for `t50` and `pUVA` are the same.

### Prep

```{r echo=TRUE, warning=FALSE, message=FALSE}

# load required libraries
library(tidyverse)
library(ape)
library(geiger)
library(mvMORPH)

# load custom functions
source("./find_transitions.R")

# set colour scheme
my_cols<-c("diurnal"="#FFA010",
         "nondiurnal"="black",
         "scansorial"="#009E73",
         "other"="black")
```

### Load data


```{r}
# data
dat<-read_csv("data_cleaned.csv")

# tree
tree<-read.tree("pruned_tree.txt")
```

Here i am loading the 'cleaned' data to avoid repeating the data cleaning from the previous script. Nonetheless, I will perform an extra filter step here, because I only want to work with species that have a complete set of data:

```{r}
## keep only the data columns I will use, and drop all species with NA's
dat_clean <- dat %>%
  select(ASW_names, hab, act, approx_size, t50, pUVA) %>%
  drop_na()

# prune tree to include only the same species
tree<-keep.tip(tree, dat_clean$ASW_names)

# reorder the data to match the order of the tree
dat_clean <-dat_clean %>%
  arrange(match(ASW_names, tree$tip.label))

all(dat_clean$ASW_names == tree$tip.label) # should be TRUE

```

### Ancestral state reconstruction:

Stochastic character mapping.

```{r fig.height=8}
# perform stochasitc character mapping
hab_tree<-make.simmap(tree=tree,
                          x=pull(dat_clean, hab, name=ASW_names),
                          model="ER", nsim=10) ## nsims here set to 10, but should ideally be higher. I doubt it will change the out come for this fairly simple data set though.
hab_ace <- describe.simmap(hab_tree, plot=F)

# pull out most likely ancestral state per node
hab_node_states <- colnames(hab_ace$ace)[apply(MAR=1, FUN=which.max, X = hab_ace$ace)]

# create a simmap object with the branches painted according to the ancestral state reconstruction
hab_tree_painted<-find_transitions(phy=tree,
                                       tip_states = dat_clean$hab,
                                       node_states = hab_node_states,
                                       simmap = T,
                                       stem_prop = 1)

plot(hab_tree_painted, colors=my_cols[unique(dat_clean$hab)], fsize=0.5)
legend("bottomleft",
       col=my_cols[unique(dat_clean$hab)],
       legend=names(my_cols[unique(dat_clean$hab)]),
       pch=19)
```
  
  
### mvMORPH model fitting for t50

We will fit four models. A Brownian motion model or an OU model with a single set of parameters for the whole tree, or a BM or OU model with different parameters for each 'regime'.

```{r}
# empty list to fill
hab_mvmodels_t50<-list()

# fill the list with the different model results
hab_mvmodels_t50$ou1<-mvOU(hab_tree_painted,
                           dat_clean[,c("approx_size","t50")],
                           model="OU1",
                           diagnostic=T, echo=F)
hab_mvmodels_t50$oum<-mvOU(hab_tree_painted,
                           dat_clean[,c("approx_size","t50")],
                           model="OUM",
                           diagnostic=T, echo=F,
                           optimization=c("Nelder-Mead")) ### NOTE THE DIFFERENT OPTOMIZATION METHOD
hab_mvmodels_t50$bm1<-mvBM(hab_tree_painted,
                           dat_clean[,c("approx_size","t50")],
                           model="BM1",
                           diagnostic=T, echo=F)
hab_mvmodels_t50$bmm<-mvBM(hab_tree_painted,
                           dat_clean[,c("approx_size","t50")],
                           model="BMM",
                           diagnostic=T, echo=F)
```
  
Withing the two model types, we could compare their fit with a log likelihood ratio test:
```{r}
LRT(hab_mvmodels_t50$oum,hab_mvmodels_t50$ou1)
LRT(hab_mvmodels_t50$bmm,hab_mvmodels_t50$bm1)
```
  
The BM models are not significantly different from each other. We can now compare the AIC scores of all 4 models:
```{r}
sort(sapply(hab_mvmodels_t50, `[[`, "AIC"))
```
    
It seems like an OU model with multiple optima is best.  
  
__NOTE:__ I used a different optimization method for the oum model because the default resulted in an optomization warning. I am honestly not 100% sure if this is ok. Perhaps something to ask Julien?
  
Parameter of this best model:

```{r}
hab_mvmodels_t50$oum
```
  
  
### mvMORPH model fitting for pUVA
  
we can repeat this for pUVA.  

```{r}
hab_mvmodels_pUVA<-list()
hab_mvmodels_pUVA$ou1<-mvOU(hab_tree_painted,
                                dat_clean[,c("approx_size","pUVA")],
                                model="OU1",
                                diagnostic=T, echo=F)
hab_mvmodels_pUVA$oum<-mvOU(hab_tree_painted,
                                dat_clean[,c("approx_size","pUVA")],
                                model="OUM",
                                diagnostic=T, echo=F)
hab_mvmodels_pUVA$bm1<-mvBM(hab_tree_painted,
                                dat_clean[,c("approx_size","pUVA")],
                                model="BM1",
                                diagnostic=T, echo=F)
hab_mvmodels_pUVA$bmm<-mvBM(hab_tree_painted,
                                dat_clean[,c("approx_size","pUVA")],
                                model="BMM",
                                diagnostic=T, echo=F)
# LRT
LRT(hab_mvmodels_pUVA$oum,hab_mvmodels_pUVA$ou1)
LRT(hab_mvmodels_pUVA$bmm,hab_mvmodels_pUVA$bm1) # not significant

# AIC scores
sort(sapply(hab_mvmodels_pUVA, `[[`, "AIC"))

# again, OUM wins
hab_mvmodels_pUVA$oum
```
  
As expected, we find the inverse pattern to t50, but again, it is reassuring to find that a multiple-optima OU model is better than a single BM model. 
  
### Summary  
  
In summary, these analyses suggest that t50 and pUVA are under selection (OU preferred over BM) and that the trait optima are different for the different regimes.
  
### mvMORPH ancestral states and data visualisation

For the purpose of visualizing these models, we could use the multi-optima OU models for ancestral state reconstructions and the display them as one or two dimensional trait grams:
    
estimate ancestral states:  
```{r}
t50_oum_anc<-estim(hab_tree_painted, dat_clean[,c("approx_size","t50")], hab_mvmodels_t50$oum, asr=TRUE)

pUVA_oum_anc<-estim(hab_tree_painted, dat_clean[,c("approx_size","pUVA")], hab_mvmodels_pUVA$oum, asr=TRUE)

```

plot phylomorphospace (2-dimensional, t50 and pUVA vs lens size)  
```{r fig.height=8, out.width="100%"}
par(mfrow=c(2,1))
par(mar=c(4,4,1,1))
# make a colour vector or tip states and node state
node_cols<-c(my_cols[dat_clean$hab],my_cols[hab_node_states])
names(node_cols)<-1:(length(hab_tree_painted$tip)+hab_tree_painted$Nnode)

#t50
phylomorphospace(tree=hab_tree_painted,
                 X=data.frame(dat_clean[,c("approx_size","t50")], row.names = dat_clean$ASW_names),
                 A=t50_oum_anc$estimates,
                 colors=my_cols,
                 label="off",
                 node.size=c(0.5,1.75),
                 pch=19,
                 control=list(col.node=node_cols)
)

#pUVA
phylomorphospace(tree=hab_tree_painted,
                 X=data.frame(dat_clean[,c("approx_size","pUVA")], row.names = dat_clean$ASW_names),
                 A=pUVA_oum_anc$estimates,
                 colors=my_cols,
                 label="off",
                 node.size=c(0.5,1.75),
                 pch=19,
                 control=list(col.node=node_cols)
)


```
  
